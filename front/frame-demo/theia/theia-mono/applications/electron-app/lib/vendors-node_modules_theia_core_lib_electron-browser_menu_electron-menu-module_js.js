"use strict";
(self["webpackChunkelectron_app"] = self["webpackChunkelectron_app"] || []).push([["vendors-node_modules_theia_core_lib_electron-browser_menu_electron-menu-module_js"],{

/***/ "../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/core/src/electron-browser/menu/electron-menu-style.css":
/*!**********************************************************************************************************************************!*\
  !*** ../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/core/src/electron-browser/menu/electron-menu-style.css ***!
  \**********************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../css-loader/dist/runtime/sourceMaps.js */ "../../node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../css-loader/dist/runtime/api.js */ "../../node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/********************************************************************************\n * Copyright (C) 2021 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\n#theia-drag-panel {\n  position: absolute;\n  display: block;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: calc(100% - 4px);\n  margin: 4px;\n  -webkit-app-region: drag !important;\n}\n\n#theia-top-panel > * {\n  -webkit-app-region: no-drag;\n}\n\n#theia-custom-title {\n  position: absolute;\n  left: 50%;\n  transform: translate(-50%, 0px);\n  line-height: 30px;\n  flex: 0 1 auto;\n  font-size: 12px;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  margin-top: 2px;\n  margin-left: auto;\n  margin-right: auto;\n  zoom: 1;\n  -webkit-app-region: drag !important;\n}\n\n#theia-custom-title.relative {\n  transform: none;\n}\n\n#theia-custom-title.hidden {\n  visibility: hidden;\n}\n\n#window-controls {\n  display: grid;\n  grid-template-columns: repeat(3, 48px);\n  position: absolute;\n  top: 0;\n  right: 0;\n  height: 100%;\n}\n\n#window-controls .control-button {\n  display: flex;\n  line-height: 30px;\n  justify-content: center;\n  align-items: center;\n  width: 100%;\n  height: 100%;\n}\n\n#minimize-button {\n  grid-column: 1;\n}\n\n#maximize-button, #restore-button {\n  grid-column: 2;\n}\n\n#close-button {\n  grid-column: 3;\n}\n\n#window-controls .control-button {\n  user-select: none;\n}\n\n#window-controls .control-button:hover {\n  background: rgba(50%, 50%, 50%, 0.2);\n}\n\n#window-controls #close-button:hover {\n  background: #E81123;\n}\n\n#window-controls #close-button:hover:before {\n  color: white;\n}\n\nbody:not(.maximized) #restore-button {\n  display: none;\n}\n\nbody.maximized #maximize-button {\n  display: none;\n}\n", "",{"version":3,"sources":["webpack://./../../node_modules/@theia/core/src/electron-browser/menu/electron-menu-style.css"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;iFAciF;;AAEjF;EACE,kBAAkB;EAClB,cAAc;EACd,MAAM;EACN,OAAO;EACP,WAAW;EACX,wBAAwB;EACxB,WAAW;EACX,mCAAmC;AACrC;;AAEA;EACE,2BAA2B;AAC7B;;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,+BAA+B;EAC/B,iBAAiB;EACjB,cAAc;EACd,eAAe;EACf,gBAAgB;EAChB,mBAAmB;EACnB,uBAAuB;EACvB,eAAe;EACf,iBAAiB;EACjB,kBAAkB;EAClB,OAAO;EACP,mCAAmC;AACrC;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,kBAAkB;AACpB;;AAEA;EACE,aAAa;EACb,sCAAsC;EACtC,kBAAkB;EAClB,MAAM;EACN,QAAQ;EACR,YAAY;AACd;;AAEA;EACE,aAAa;EACb,iBAAiB;EACjB,uBAAuB;EACvB,mBAAmB;EACnB,WAAW;EACX,YAAY;AACd;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,oCAAoC;AACtC;;AAEA;EACE,mBAAmB;AACrB;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,aAAa;AACf","sourcesContent":["/********************************************************************************\n * Copyright (C) 2021 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\n#theia-drag-panel {\n  position: absolute;\n  display: block;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: calc(100% - 4px);\n  margin: 4px;\n  -webkit-app-region: drag !important;\n}\n\n#theia-top-panel > * {\n  -webkit-app-region: no-drag;\n}\n\n#theia-custom-title {\n  position: absolute;\n  left: 50%;\n  transform: translate(-50%, 0px);\n  line-height: 30px;\n  flex: 0 1 auto;\n  font-size: 12px;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  margin-top: 2px;\n  margin-left: auto;\n  margin-right: auto;\n  zoom: 1;\n  -webkit-app-region: drag !important;\n}\n\n#theia-custom-title.relative {\n  transform: none;\n}\n\n#theia-custom-title.hidden {\n  visibility: hidden;\n}\n\n#window-controls {\n  display: grid;\n  grid-template-columns: repeat(3, 48px);\n  position: absolute;\n  top: 0;\n  right: 0;\n  height: 100%;\n}\n\n#window-controls .control-button {\n  display: flex;\n  line-height: 30px;\n  justify-content: center;\n  align-items: center;\n  width: 100%;\n  height: 100%;\n}\n\n#minimize-button {\n  grid-column: 1;\n}\n\n#maximize-button, #restore-button {\n  grid-column: 2;\n}\n\n#close-button {\n  grid-column: 3;\n}\n\n#window-controls .control-button {\n  user-select: none;\n}\n\n#window-controls .control-button:hover {\n  background: rgba(50%, 50%, 50%, 0.2);\n}\n\n#window-controls #close-button:hover {\n  background: #E81123;\n}\n\n#window-controls #close-button:hover:before {\n  color: white;\n}\n\nbody:not(.maximized) #restore-button {\n  display: none;\n}\n\nbody.maximized #maximize-button {\n  display: none;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "../../node_modules/@theia/core/lib/browser/menu/browser-context-menu-renderer.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@theia/core/lib/browser/menu/browser-context-menu-renderer.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// *****************************************************************************
// Copyright (C) 2017 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
// *****************************************************************************
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowserContextMenuRenderer = exports.BrowserContextMenuAccess = void 0;
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/lib/inversify.js");
const context_menu_renderer_1 = __webpack_require__(/*! ../context-menu-renderer */ "../../node_modules/@theia/core/lib/browser/context-menu-renderer.js");
const browser_menu_plugin_1 = __webpack_require__(/*! ./browser-menu-plugin */ "../../node_modules/@theia/core/lib/browser/menu/browser-menu-plugin.js");
class BrowserContextMenuAccess extends context_menu_renderer_1.ContextMenuAccess {
    constructor(menu) {
        super(menu);
        this.menu = menu;
    }
}
exports.BrowserContextMenuAccess = BrowserContextMenuAccess;
let BrowserContextMenuRenderer = class BrowserContextMenuRenderer extends context_menu_renderer_1.ContextMenuRenderer {
    constructor(menuFactory) {
        super();
        this.menuFactory = menuFactory;
    }
    doRender({ menuPath, anchor, args, onHide, context, contextKeyService }) {
        const contextMenu = this.menuFactory.createContextMenu(menuPath, args, context, contextKeyService);
        const { x, y } = (0, context_menu_renderer_1.coordinateFromAnchor)(anchor);
        if (onHide) {
            contextMenu.aboutToClose.connect(() => onHide());
        }
        contextMenu.open(x, y);
        return new BrowserContextMenuAccess(contextMenu);
    }
};
BrowserContextMenuRenderer = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(browser_menu_plugin_1.BrowserMainMenuFactory)),
    __metadata("design:paramtypes", [browser_menu_plugin_1.BrowserMainMenuFactory])
], BrowserContextMenuRenderer);
exports.BrowserContextMenuRenderer = BrowserContextMenuRenderer;


/***/ }),

/***/ "../../node_modules/@theia/core/lib/browser/menu/browser-menu-plugin.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@theia/core/lib/browser/menu/browser-menu-plugin.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// *****************************************************************************
// Copyright (C) 2017 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
// *****************************************************************************
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MenuCommandRegistry = exports.BrowserMenuBarContribution = exports.DynamicMenuWidget = exports.MenuServices = exports.DynamicMenuBarWidget = exports.BrowserMainMenuFactory = exports.MenuBarWidget = void 0;
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/lib/inversify.js");
const widgets_1 = __webpack_require__(/*! @phosphor/widgets */ "../../node_modules/@phosphor/widgets/lib/index.js");
const commands_1 = __webpack_require__(/*! @phosphor/commands */ "../../node_modules/@phosphor/commands/lib/index.js");
const common_1 = __webpack_require__(/*! ../../common */ "../../node_modules/@theia/core/lib/common/index.js");
const keybinding_1 = __webpack_require__(/*! ../keybinding */ "../../node_modules/@theia/core/lib/browser/keybinding.js");
const context_key_service_1 = __webpack_require__(/*! ../context-key-service */ "../../node_modules/@theia/core/lib/browser/context-key-service.js");
const context_menu_context_1 = __webpack_require__(/*! ./context-menu-context */ "../../node_modules/@theia/core/lib/browser/menu/context-menu-context.js");
const widgets_2 = __webpack_require__(/*! ../widgets */ "../../node_modules/@theia/core/lib/browser/widgets/index.js");
const shell_1 = __webpack_require__(/*! ../shell */ "../../node_modules/@theia/core/lib/browser/shell/index.js");
const core_preferences_1 = __webpack_require__(/*! ../core-preferences */ "../../node_modules/@theia/core/lib/browser/core-preferences.js");
const preference_service_1 = __webpack_require__(/*! ../preferences/preference-service */ "../../node_modules/@theia/core/lib/browser/preferences/preference-service.js");
class MenuBarWidget extends widgets_1.MenuBar {
}
exports.MenuBarWidget = MenuBarWidget;
;
let BrowserMainMenuFactory = class BrowserMainMenuFactory {
    createMenuBar() {
        const menuBar = new DynamicMenuBarWidget();
        menuBar.id = 'theia:menubar';
        this.corePreferences.ready.then(() => {
            this.showMenuBar(menuBar, this.corePreferences.get('window.menuBarVisibility', 'classic'));
        });
        const preferenceListener = this.corePreferences.onPreferenceChanged(preference => {
            if (preference.preferenceName === 'window.menuBarVisibility') {
                this.showMenuBar(menuBar, preference.newValue);
            }
        });
        const keybindingListener = this.keybindingRegistry.onKeybindingsChanged(() => {
            const preference = this.corePreferences['window.menuBarVisibility'];
            this.showMenuBar(menuBar, preference);
        });
        menuBar.disposed.connect(() => {
            preferenceListener.dispose();
            keybindingListener.dispose();
        });
        return menuBar;
    }
    showMenuBar(menuBar, preference) {
        if (preference && ['classic', 'visible'].includes(preference)) {
            menuBar.clearMenus();
            this.fillMenuBar(menuBar);
        }
        else {
            menuBar.clearMenus();
        }
    }
    fillMenuBar(menuBar) {
        const menuModel = this.menuProvider.getMenu(common_1.MAIN_MENU_BAR);
        const menuCommandRegistry = this.createMenuCommandRegistry(menuModel);
        for (const menu of menuModel.children) {
            if (common_1.CompoundMenuNode.is(menu)) {
                const menuWidget = this.createMenuWidget(menu, { commands: menuCommandRegistry, rootMenuPath: common_1.MAIN_MENU_BAR });
                menuBar.addMenu(menuWidget);
            }
        }
    }
    createContextMenu(path, args, context, contextKeyService) {
        const menuModel = this.menuProvider.getMenu(path);
        const menuCommandRegistry = this.createMenuCommandRegistry(menuModel, args).snapshot(path);
        const contextMenu = this.createMenuWidget(menuModel, { commands: menuCommandRegistry, context, rootMenuPath: path, contextKeyService });
        return contextMenu;
    }
    createMenuWidget(menu, options) {
        return new DynamicMenuWidget(menu, options, this.services);
    }
    createMenuCommandRegistry(menu, args = []) {
        const menuCommandRegistry = new MenuCommandRegistry(this.services);
        this.registerMenu(menuCommandRegistry, menu, args);
        return menuCommandRegistry;
    }
    registerMenu(menuCommandRegistry, menu, args) {
        if (common_1.CompoundMenuNode.is(menu)) {
            menu.children.forEach(child => this.registerMenu(menuCommandRegistry, child, args));
        }
        else if (common_1.CommandMenuNode.is(menu)) {
            menuCommandRegistry.registerActionMenu(menu, args);
            if (common_1.CommandMenuNode.hasAltHandler(menu)) {
                menuCommandRegistry.registerActionMenu(menu.altNode, args);
            }
        }
    }
    get services() {
        return {
            context: this.context,
            contextKeyService: this.contextKeyService,
            commandRegistry: this.commandRegistry,
            keybindingRegistry: this.keybindingRegistry,
            menuWidgetFactory: this,
            commandExecutor: this.menuCommandExecutor,
        };
    }
};
__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    __metadata("design:type", Object)
], BrowserMainMenuFactory.prototype, "contextKeyService", void 0);
__decorate([
    (0, inversify_1.inject)(context_menu_context_1.ContextMenuContext),
    __metadata("design:type", context_menu_context_1.ContextMenuContext)
], BrowserMainMenuFactory.prototype, "context", void 0);
__decorate([
    (0, inversify_1.inject)(common_1.CommandRegistry),
    __metadata("design:type", common_1.CommandRegistry)
], BrowserMainMenuFactory.prototype, "commandRegistry", void 0);
__decorate([
    (0, inversify_1.inject)(common_1.MenuCommandExecutor),
    __metadata("design:type", Object)
], BrowserMainMenuFactory.prototype, "menuCommandExecutor", void 0);
__decorate([
    (0, inversify_1.inject)(core_preferences_1.CorePreferences),
    __metadata("design:type", Object)
], BrowserMainMenuFactory.prototype, "corePreferences", void 0);
__decorate([
    (0, inversify_1.inject)(keybinding_1.KeybindingRegistry),
    __metadata("design:type", keybinding_1.KeybindingRegistry)
], BrowserMainMenuFactory.prototype, "keybindingRegistry", void 0);
__decorate([
    (0, inversify_1.inject)(common_1.MenuModelRegistry),
    __metadata("design:type", common_1.MenuModelRegistry)
], BrowserMainMenuFactory.prototype, "menuProvider", void 0);
BrowserMainMenuFactory = __decorate([
    (0, inversify_1.injectable)()
], BrowserMainMenuFactory);
exports.BrowserMainMenuFactory = BrowserMainMenuFactory;
class DynamicMenuBarWidget extends MenuBarWidget {
    constructor() {
        super();
        // HACK we need to hook in on private method _openChildMenu. Don't do this at home!
        DynamicMenuBarWidget.prototype['_openChildMenu'] = () => {
            if (this.activeMenu instanceof DynamicMenuWidget) {
                // `childMenu` is `null` if we open the menu. For example, menu is not shown and you click on `Edit`.
                // However, the `childMenu` is set, when `Edit` was already open and you move the mouse over `Select`.
                // We want to save the focus object for the former case only.
                if (!this.childMenu) {
                    const { activeElement } = document;
                    if (activeElement instanceof HTMLElement) {
                        this.previousFocusedElement = activeElement;
                    }
                }
                this.activeMenu.aboutToShow({ previousFocusedElement: this.previousFocusedElement });
            }
            super['_openChildMenu']();
        };
    }
    async activateMenu(label, ...labels) {
        const menu = this.menus.find(m => m.title.label === label);
        if (!menu) {
            throw new Error(`could not find '${label}' menu`);
        }
        this.activeMenu = menu;
        this.openActiveMenu();
        await (0, widgets_2.waitForRevealed)(menu);
        const menuPath = [label];
        let current = menu;
        for (const itemLabel of labels) {
            const item = current.items.find(i => i.label === itemLabel);
            if (!item || !item.submenu) {
                throw new Error(`could not find '${label}' submenu in ${menuPath.map(l => "'" + l + "'").join(' -> ')} menu`);
            }
            current.activeItem = item;
            current.triggerActiveItem();
            current = item.submenu;
            await (0, widgets_2.waitForRevealed)(current);
        }
        return current;
    }
    async triggerMenuItem(label, ...labels) {
        if (!labels.length) {
            throw new Error('menu item label is not specified');
        }
        const menuPath = [label, ...labels.slice(0, labels.length - 1)];
        const menu = await this.activateMenu(menuPath[0], ...menuPath.slice(1));
        const item = menu.items.find(i => i.label === labels[labels.length - 1]);
        if (!item) {
            throw new Error(`could not find '${label}' item in ${menuPath.map(l => "'" + l + "'").join(' -> ')} menu`);
        }
        menu.activeItem = item;
        menu.triggerActiveItem();
        return item;
    }
}
exports.DynamicMenuBarWidget = DynamicMenuBarWidget;
class MenuServices {
}
exports.MenuServices = MenuServices;
/**
 * A menu widget that would recompute its items on update.
 */
class DynamicMenuWidget extends widgets_1.Menu {
    constructor(menu, options, services) {
        super(options);
        this.menu = menu;
        this.options = options;
        this.services = services;
        if (menu.label) {
            this.title.label = menu.label;
        }
        if (menu.icon) {
            this.title.iconClass = menu.icon;
        }
        this.updateSubMenus(this, this.menu, this.options.commands);
    }
    aboutToShow({ previousFocusedElement }) {
        this.preserveFocusedElement(previousFocusedElement);
        this.clearItems();
        this.runWithPreservedFocusContext(() => {
            this.options.commands.snapshot(this.options.rootMenuPath);
            this.updateSubMenus(this, this.menu, this.options.commands);
        });
    }
    open(x, y, options) {
        const cb = () => {
            this.restoreFocusedElement();
            this.aboutToClose.disconnect(cb);
        };
        this.aboutToClose.connect(cb);
        this.preserveFocusedElement();
        super.open(x, y, options);
    }
    updateSubMenus(parent, menu, commands) {
        var _a;
        const items = this.buildSubMenus([], menu, commands);
        while (((_a = items[items.length - 1]) === null || _a === void 0 ? void 0 : _a.type) === 'separator') {
            items.pop();
        }
        for (const item of items) {
            parent.addItem(item);
        }
    }
    buildSubMenus(parentItems, menu, commands) {
        var _a, _b;
        if (common_1.CompoundMenuNode.is(menu)
            && menu.children.length
            && this.undefinedOrMatch((_a = this.options.contextKeyService) !== null && _a !== void 0 ? _a : this.services.contextKeyService, menu.when, this.options.context)) {
            const role = menu === this.menu ? 1 /* Group */ : common_1.CompoundMenuNode.getRole(menu);
            if (role === 0 /* Submenu */) {
                const submenu = this.services.menuWidgetFactory.createMenuWidget(menu, this.options);
                if (submenu.items.length > 0) {
                    parentItems.push({ type: 'submenu', submenu });
                }
            }
            else if (role === 1 /* Group */ && menu.id !== 'inline') {
                const children = common_1.CompoundMenuNode.getFlatChildren(menu.children);
                const myItems = [];
                children.forEach(child => this.buildSubMenus(myItems, child, commands));
                if (myItems.length) {
                    if (parentItems.length && parentItems[parentItems.length - 1].type !== 'separator') {
                        parentItems.push({ type: 'separator' });
                    }
                    parentItems.push(...myItems);
                    parentItems.push({ type: 'separator' });
                }
            }
        }
        else if (menu.command) {
            const node = menu.altNode && this.services.context.altPressed ? menu.altNode : menu;
            if (commands.isVisible(node.command) && this.undefinedOrMatch((_b = this.options.contextKeyService) !== null && _b !== void 0 ? _b : this.services.contextKeyService, node.when, this.options.context)) {
                parentItems.push({
                    command: node.command,
                    type: 'command'
                });
            }
        }
        return parentItems;
    }
    undefinedOrMatch(contextKeyService, expression, context) {
        if (expression) {
            return contextKeyService.match(expression, context);
        }
        return true;
    }
    preserveFocusedElement(previousFocusedElement = document.activeElement) {
        if (!this.previousFocusedElement && previousFocusedElement instanceof HTMLElement) {
            this.previousFocusedElement = previousFocusedElement;
            return true;
        }
        return false;
    }
    restoreFocusedElement() {
        if (this.previousFocusedElement) {
            this.previousFocusedElement.focus({ preventScroll: true });
            this.previousFocusedElement = undefined;
            return true;
        }
        return false;
    }
    runWithPreservedFocusContext(what) {
        let focusToRestore = undefined;
        const { activeElement } = document;
        if (this.previousFocusedElement && activeElement instanceof HTMLElement && this.previousFocusedElement !== activeElement) {
            focusToRestore = activeElement;
            this.previousFocusedElement.focus({ preventScroll: true });
        }
        try {
            what();
        }
        finally {
            if (focusToRestore) {
                focusToRestore.focus({ preventScroll: true });
            }
        }
    }
}
exports.DynamicMenuWidget = DynamicMenuWidget;
let BrowserMenuBarContribution = class BrowserMenuBarContribution {
    constructor(factory) {
        this.factory = factory;
    }
    onStart(app) {
        this.appendMenu(app.shell);
    }
    get menuBar() {
        return this.shell.topPanel.widgets.find(w => w instanceof MenuBarWidget);
    }
    appendMenu(shell) {
        const logo = this.createLogo();
        shell.addWidget(logo, { area: 'top' });
        const menu = this.factory.createMenuBar();
        shell.addWidget(menu, { area: 'top' });
        // Hiding the menu is only necessary in electron
        // In the browser we hide the whole top panel
        if (common_1.environment.electron.is()) {
            this.preferenceService.ready.then(() => {
                menu.setHidden(['compact', 'hidden'].includes(this.preferenceService.get('window.menuBarVisibility', '')));
            });
            this.preferenceService.onPreferenceChanged(change => {
                if (change.preferenceName === 'window.menuBarVisibility') {
                    menu.setHidden(['compact', 'hidden'].includes(change.newValue));
                }
            });
        }
    }
    createLogo() {
        const logo = new widgets_1.Widget();
        logo.id = 'theia:icon';
        logo.addClass('theia-icon');
        return logo;
    }
};
__decorate([
    (0, inversify_1.inject)(shell_1.ApplicationShell),
    __metadata("design:type", shell_1.ApplicationShell)
], BrowserMenuBarContribution.prototype, "shell", void 0);
__decorate([
    (0, inversify_1.inject)(preference_service_1.PreferenceService),
    __metadata("design:type", Object)
], BrowserMenuBarContribution.prototype, "preferenceService", void 0);
BrowserMenuBarContribution = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(BrowserMainMenuFactory)),
    __metadata("design:paramtypes", [BrowserMainMenuFactory])
], BrowserMenuBarContribution);
exports.BrowserMenuBarContribution = BrowserMenuBarContribution;
/**
 * Stores Theia-specific action menu nodes instead of PhosphorJS commands with their handlers.
 */
class MenuCommandRegistry extends commands_1.CommandRegistry {
    constructor(services) {
        super();
        this.services = services;
        this.actions = new Map();
        this.toDispose = new common_1.DisposableCollection();
    }
    registerActionMenu(menu, args) {
        const { commandRegistry } = this.services;
        const command = commandRegistry.getCommand(menu.command);
        if (!command) {
            return;
        }
        const { id } = command;
        if (this.actions.has(id)) {
            return;
        }
        this.actions.set(id, [menu, args]);
    }
    snapshot(menuPath) {
        this.toDispose.dispose();
        for (const [menu, args] of this.actions.values()) {
            this.toDispose.push(this.registerCommand(menu, args, menuPath));
        }
        return this;
    }
    registerCommand(menu, args, menuPath) {
        const { commandRegistry, keybindingRegistry, commandExecutor } = this.services;
        const command = commandRegistry.getCommand(menu.command);
        if (!command) {
            return common_1.Disposable.NULL;
        }
        const { id } = command;
        if (this.hasCommand(id)) {
            // several menu items can be registered for the same command in different contexts
            return common_1.Disposable.NULL;
        }
        // We freeze the `isEnabled`, `isVisible`, and `isToggled` states so they won't change.
        const enabled = commandExecutor.isEnabled(menuPath, id, ...args);
        const visible = commandExecutor.isVisible(menuPath, id, ...args);
        const toggled = commandExecutor.isToggled(menuPath, id, ...args);
        const unregisterCommand = this.addCommand(id, {
            execute: () => commandExecutor.executeCommand(menuPath, id, ...args),
            label: menu.label,
            icon: menu.icon,
            isEnabled: () => enabled,
            isVisible: () => visible,
            isToggled: () => toggled
        });
        const bindings = keybindingRegistry.getKeybindingsForCommand(id);
        // Only consider the first keybinding.
        if (bindings.length) {
            const binding = bindings[0];
            const keys = keybindingRegistry.acceleratorFor(binding, ' ', true);
            this.addKeyBinding({
                command: id,
                keys,
                selector: '.p-Widget' // We have the PhosphorJS dependency anyway.
            });
        }
        return common_1.Disposable.create(() => unregisterCommand.dispose());
    }
}
exports.MenuCommandRegistry = MenuCommandRegistry;


/***/ }),

/***/ "../../node_modules/@theia/core/lib/electron-browser/menu/electron-context-menu-renderer.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/@theia/core/lib/electron-browser/menu/electron-context-menu-renderer.js ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// *****************************************************************************
// Copyright (C) 2017 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
// *****************************************************************************
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ElectronContextMenuRenderer = exports.ElectronTextInputContextMenuContribution = exports.ElectronTextInputContextMenu = exports.ElectronContextMenuAccess = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/lib/inversify.js");
const browser_1 = __webpack_require__(/*! ../../browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const electron_main_menu_factory_1 = __webpack_require__(/*! ./electron-main-menu-factory */ "../../node_modules/@theia/core/lib/electron-browser/menu/electron-main-menu-factory.js");
const context_menu_context_1 = __webpack_require__(/*! ../../browser/menu/context-menu-context */ "../../node_modules/@theia/core/lib/browser/menu/context-menu-context.js");
const browser_context_menu_renderer_1 = __webpack_require__(/*! ../../browser/menu/browser-context-menu-renderer */ "../../node_modules/@theia/core/lib/browser/menu/browser-context-menu-renderer.js");
class ElectronContextMenuAccess extends browser_1.ContextMenuAccess {
    constructor(menuHandle) {
        super({
            dispose: () => menuHandle.then(handle => window.electronTheiaCore.closePopup(handle))
        });
        this.menuHandle = menuHandle;
    }
}
exports.ElectronContextMenuAccess = ElectronContextMenuAccess;
var ElectronTextInputContextMenu;
(function (ElectronTextInputContextMenu) {
    ElectronTextInputContextMenu.MENU_PATH = ['electron_text_input'];
    ElectronTextInputContextMenu.UNDO_REDO_EDIT_GROUP = [...ElectronTextInputContextMenu.MENU_PATH, '0_undo_redo_group'];
    ElectronTextInputContextMenu.EDIT_GROUP = [...ElectronTextInputContextMenu.MENU_PATH, '1_edit_group'];
    ElectronTextInputContextMenu.SELECT_GROUP = [...ElectronTextInputContextMenu.MENU_PATH, '2_select_group'];
})(ElectronTextInputContextMenu = exports.ElectronTextInputContextMenu || (exports.ElectronTextInputContextMenu = {}));
let ElectronTextInputContextMenuContribution = class ElectronTextInputContextMenuContribution {
    onStart() {
        window.document.addEventListener('contextmenu', event => {
            if (event.target instanceof HTMLElement) {
                const target = event.target;
                if (target.nodeName && (target.nodeName.toLowerCase() === 'input' || target.nodeName.toLowerCase() === 'textarea')) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.contextMenuRenderer.render({
                        anchor: event,
                        menuPath: ElectronTextInputContextMenu.MENU_PATH,
                        onHide: () => target.focus()
                    });
                }
            }
        });
    }
    registerMenus(registry) {
        registry.registerMenuAction(ElectronTextInputContextMenu.UNDO_REDO_EDIT_GROUP, { commandId: browser_1.CommonCommands.UNDO.id });
        registry.registerMenuAction(ElectronTextInputContextMenu.UNDO_REDO_EDIT_GROUP, { commandId: browser_1.CommonCommands.REDO.id });
        registry.registerMenuAction(ElectronTextInputContextMenu.EDIT_GROUP, { commandId: browser_1.CommonCommands.CUT.id });
        registry.registerMenuAction(ElectronTextInputContextMenu.EDIT_GROUP, { commandId: browser_1.CommonCommands.COPY.id });
        registry.registerMenuAction(ElectronTextInputContextMenu.EDIT_GROUP, { commandId: browser_1.CommonCommands.PASTE.id });
        registry.registerMenuAction(ElectronTextInputContextMenu.SELECT_GROUP, { commandId: browser_1.CommonCommands.SELECT_ALL.id });
    }
};
__decorate([
    (0, inversify_1.inject)(browser_1.ContextMenuRenderer),
    __metadata("design:type", browser_1.ContextMenuRenderer)
], ElectronTextInputContextMenuContribution.prototype, "contextMenuRenderer", void 0);
ElectronTextInputContextMenuContribution = __decorate([
    (0, inversify_1.injectable)()
], ElectronTextInputContextMenuContribution);
exports.ElectronTextInputContextMenuContribution = ElectronTextInputContextMenuContribution;
let ElectronContextMenuRenderer = class ElectronContextMenuRenderer extends browser_context_menu_renderer_1.BrowserContextMenuRenderer {
    constructor(electronMenuFactory) {
        super(electronMenuFactory);
        this.electronMenuFactory = electronMenuFactory;
        this.useNativeStyle = true;
    }
    async init() {
        this.useNativeStyle = await window.electronTheiaCore.getTitleBarStyleAtStartup() === 'native';
    }
    doRender(options) {
        if (this.useNativeStyle) {
            const { menuPath, anchor, args, onHide, context, contextKeyService } = options;
            const menu = this.electronMenuFactory.createElectronContextMenu(menuPath, args, context, contextKeyService);
            const { x, y } = (0, browser_1.coordinateFromAnchor)(anchor);
            const menuHandle = window.electronTheiaCore.popup(menu, x, y, () => {
                if (onHide) {
                    onHide();
                }
            });
            // native context menu stops the event loop, so there is no keyboard events
            this.context.resetAltPressed();
            return new ElectronContextMenuAccess(menuHandle);
        }
        else {
            return super.doRender(options);
        }
    }
};
__decorate([
    (0, inversify_1.inject)(context_menu_context_1.ContextMenuContext),
    __metadata("design:type", context_menu_context_1.ContextMenuContext)
], ElectronContextMenuRenderer.prototype, "context", void 0);
__decorate([
    (0, inversify_1.inject)(browser_1.PreferenceService),
    __metadata("design:type", Object)
], ElectronContextMenuRenderer.prototype, "preferenceService", void 0);
__decorate([
    (0, inversify_1.postConstruct)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ElectronContextMenuRenderer.prototype, "init", null);
ElectronContextMenuRenderer = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(electron_main_menu_factory_1.ElectronMainMenuFactory)),
    __metadata("design:paramtypes", [electron_main_menu_factory_1.ElectronMainMenuFactory])
], ElectronContextMenuRenderer);
exports.ElectronContextMenuRenderer = ElectronContextMenuRenderer;


/***/ }),

/***/ "../../node_modules/@theia/core/lib/electron-browser/menu/electron-main-menu-factory.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@theia/core/lib/electron-browser/menu/electron-main-menu-factory.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// *****************************************************************************
// Copyright (C) 2017 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
// *****************************************************************************
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ElectronMainMenuFactory = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/lib/inversify.js");
const common_1 = __webpack_require__(/*! ../../common */ "../../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! ../../browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const debounce = __webpack_require__(/*! lodash.debounce */ "../../node_modules/lodash.debounce/index.js");
const theia_dock_panel_1 = __webpack_require__(/*! ../../browser/shell/theia-dock-panel */ "../../node_modules/@theia/core/lib/browser/shell/theia-dock-panel.js");
const browser_menu_plugin_1 = __webpack_require__(/*! ../../browser/menu/browser-menu-plugin */ "../../node_modules/@theia/core/lib/browser/menu/browser-menu-plugin.js");
let ElectronMainMenuFactory = class ElectronMainMenuFactory extends browser_menu_plugin_1.BrowserMainMenuFactory {
    constructor() {
        super(...arguments);
        this._toggledCommands = new Set();
    }
    postConstruct() {
        this.preferencesService.onPreferenceChanged(debounce(e => {
            if (e.preferenceName === 'window.menuBarVisibility') {
                this.setMenuBar();
            }
            if (this._menu) {
                for (const cmd of this._toggledCommands) {
                    const menuItem = this.findMenuById(this._menu, cmd);
                    if (menuItem) {
                        menuItem.checked = this.commandRegistry.isToggled(cmd);
                    }
                }
                window.electronTheiaCore.setMenu(this._menu);
            }
        }, 10));
        this.keybindingRegistry.onKeybindingsChanged(() => {
            this.setMenuBar();
        });
    }
    async setMenuBar() {
        await this.preferencesService.ready;
        const createdMenuBar = this.createElectronMenuBar();
        window.electronTheiaCore.setMenu(createdMenuBar);
    }
    createElectronMenuBar() {
        const preference = this.preferencesService.get('window.menuBarVisibility') || 'classic';
        const maxWidget = document.getElementsByClassName(theia_dock_panel_1.MAXIMIZED_CLASS);
        if (preference === 'visible' || (preference === 'classic' && maxWidget.length === 0)) {
            const menuModel = this.menuProvider.getMenu(common_1.MAIN_MENU_BAR);
            this._menu = this.fillMenuTemplate([], menuModel, [], { rootMenuPath: common_1.MAIN_MENU_BAR });
            if (common_1.isOSX) {
                this._menu.unshift(this.createOSXMenu());
            }
            return this._menu;
        }
        this._menu = undefined;
        // eslint-disable-next-line no-null/no-null
        return undefined;
    }
    createElectronContextMenu(menuPath, args, context, contextKeyService) {
        const menuModel = this.menuProvider.getMenu(menuPath);
        return this.fillMenuTemplate([], menuModel, args, { showDisabled: false, context, rootMenuPath: menuPath, contextKeyService });
    }
    fillMenuTemplate(parentItems, menu, args = [], options) {
        var _a, _b;
        const showDisabled = (options === null || options === void 0 ? void 0 : options.showDisabled) !== false;
        if (common_1.CompoundMenuNode.is(menu) && menu.children.length && this.undefinedOrMatch((_a = options.contextKeyService) !== null && _a !== void 0 ? _a : this.contextKeyService, menu.when, options.context)) {
            const role = common_1.CompoundMenuNode.getRole(menu);
            if (role === 1 /* Group */ && menu.id === 'inline') {
                return parentItems;
            }
            const children = common_1.CompoundMenuNode.getFlatChildren(menu.children);
            const myItems = [];
            children.forEach(child => this.fillMenuTemplate(myItems, child, args, options));
            if (myItems.length === 0) {
                return parentItems;
            }
            if (role === 0 /* Submenu */) {
                parentItems.push({ label: menu.label, submenu: myItems });
            }
            else if (role === 1 /* Group */ && menu.id !== 'inline') {
                if (parentItems.length && parentItems[parentItems.length - 1].type !== 'separator') {
                    parentItems.push({ type: 'separator' });
                }
                parentItems.push(...myItems);
                parentItems.push({ type: 'separator' });
            }
        }
        else if (menu.command) {
            const node = menu.altNode && this.context.altPressed ? menu.altNode : menu;
            const commandId = node.command;
            // That is only a sanity check at application startup.
            if (!this.commandRegistry.getCommand(commandId)) {
                console.debug(`Skipping menu item with missing command: "${commandId}".`);
                return parentItems;
            }
            if (!this.menuCommandExecutor.isVisible(options.rootMenuPath, commandId, ...args)
                || !this.undefinedOrMatch((_b = options.contextKeyService) !== null && _b !== void 0 ? _b : this.contextKeyService, node.when, options.context)) {
                return parentItems;
            }
            // We should omit rendering context-menu items which are disabled.
            if (!showDisabled && !this.menuCommandExecutor.isEnabled(options.rootMenuPath, commandId, ...args)) {
                return parentItems;
            }
            const bindings = this.keybindingRegistry.getKeybindingsForCommand(commandId);
            const accelerator = bindings[0] && this.acceleratorFor(bindings[0]);
            const menuItem = {
                id: node.id,
                label: node.label,
                type: this.commandRegistry.getToggledHandler(commandId, ...args) ? 'checkbox' : 'normal',
                checked: this.commandRegistry.isToggled(commandId, ...args),
                enabled: true,
                visible: true,
                accelerator,
                execute: () => this.execute(commandId, args, options.rootMenuPath)
            };
            if (common_1.isOSX) {
                const role = this.roleFor(node.id);
                if (role) {
                    menuItem.role = role;
                    delete menuItem.execute;
                }
            }
            parentItems.push(menuItem);
            if (this.commandRegistry.getToggledHandler(commandId, ...args)) {
                this._toggledCommands.add(commandId);
            }
        }
        return parentItems;
    }
    undefinedOrMatch(contextKeyService, expression, context) {
        if (expression) {
            return contextKeyService.match(expression, context);
        }
        return true;
    }
    /**
     * Return a user visible representation of a keybinding.
     */
    acceleratorFor(keybinding) {
        const bindingKeySequence = this.keybindingRegistry.resolveKeybinding(keybinding);
        // FIXME see https://github.com/electron/electron/issues/11740
        // Key Sequences can't be represented properly in the electron menu.
        //
        // We can do what VS Code does, and append the chords as a suffix to the menu label.
        // https://github.com/eclipse-theia/theia/issues/1199#issuecomment-430909480
        if (bindingKeySequence.length > 1) {
            return '';
        }
        const keyCode = bindingKeySequence[0];
        return this.keybindingRegistry.acceleratorForKeyCode(keyCode, '+', true);
    }
    roleFor(id) {
        let role;
        switch (id) {
            case browser_1.CommonCommands.UNDO.id:
                role = 'undo';
                break;
            case browser_1.CommonCommands.REDO.id:
                role = 'redo';
                break;
            case browser_1.CommonCommands.CUT.id:
                role = 'cut';
                break;
            case browser_1.CommonCommands.COPY.id:
                role = 'copy';
                break;
            case browser_1.CommonCommands.PASTE.id:
                role = 'paste';
                break;
            case browser_1.CommonCommands.SELECT_ALL.id:
                role = 'selectAll';
                break;
            default:
                break;
        }
        return role;
    }
    async execute(cmd, args, menuPath) {
        try {
            // This is workaround for https://github.com/eclipse-theia/theia/issues/446.
            // Electron menus do not update based on the `isEnabled`, `isVisible` property of the command.
            // We need to check if we can execute it.
            if (this.menuCommandExecutor.isEnabled(menuPath, cmd, ...args)) {
                await this.menuCommandExecutor.executeCommand(menuPath, cmd, ...args);
                if (this._menu && this.menuCommandExecutor.isVisible(menuPath, cmd, ...args)) {
                    const item = this.findMenuById(this._menu, cmd);
                    if (item) {
                        item.checked = this.menuCommandExecutor.isToggled(menuPath, cmd, ...args);
                        window.electronTheiaCore.setMenu(this._menu);
                    }
                }
            }
        }
        catch (_a) {
            // no-op
        }
    }
    findMenuById(items, id) {
        for (const item of items) {
            if (item.id === id) {
                return item;
            }
            if (item.submenu) {
                const found = this.findMenuById(item.submenu, id);
                if (found) {
                    return found;
                }
            }
        }
        return undefined;
    }
    createOSXMenu() {
        return {
            label: 'Theia',
            submenu: [
                {
                    role: 'about'
                },
                {
                    type: 'separator'
                },
                {
                    role: 'services',
                    submenu: []
                },
                {
                    type: 'separator'
                },
                {
                    role: 'hide'
                },
                {
                    role: 'hideOthers'
                },
                {
                    role: 'unhide'
                },
                {
                    type: 'separator'
                },
                {
                    role: 'quit'
                }
            ]
        };
    }
};
__decorate([
    (0, inversify_1.inject)(browser_1.PreferenceService),
    __metadata("design:type", Object)
], ElectronMainMenuFactory.prototype, "preferencesService", void 0);
__decorate([
    (0, inversify_1.postConstruct)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], ElectronMainMenuFactory.prototype, "postConstruct", null);
ElectronMainMenuFactory = __decorate([
    (0, inversify_1.injectable)()
], ElectronMainMenuFactory);
exports.ElectronMainMenuFactory = ElectronMainMenuFactory;


/***/ }),

/***/ "../../node_modules/@theia/core/lib/electron-browser/menu/electron-menu-contribution.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@theia/core/lib/electron-browser/menu/electron-menu-contribution.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// *****************************************************************************
// Copyright (C) 2017 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
// *****************************************************************************
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CustomTitleWidget = exports.ElectronMenuContribution = exports.CustomTitleWidgetFactory = exports.ElectronMenus = exports.ElectronCommands = void 0;
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/lib/inversify.js");
const common_1 = __webpack_require__(/*! ../../common */ "../../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! ../../browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const electron_main_menu_factory_1 = __webpack_require__(/*! ./electron-main-menu-factory */ "../../node_modules/@theia/core/lib/electron-browser/menu/electron-main-menu-factory.js");
const frontend_application_state_1 = __webpack_require__(/*! ../../browser/frontend-application-state */ "../../node_modules/@theia/core/lib/browser/frontend-application-state.js");
const frontend_application_config_provider_1 = __webpack_require__(/*! ../../browser/frontend-application-config-provider */ "../../node_modules/@theia/core/lib/browser/frontend-application-config-provider.js");
const electron_window_preferences_1 = __webpack_require__(/*! ../window/electron-window-preferences */ "../../node_modules/@theia/core/lib/electron-browser/window/electron-window-preferences.js");
const browser_menu_plugin_1 = __webpack_require__(/*! ../../browser/menu/browser-menu-plugin */ "../../node_modules/@theia/core/lib/browser/menu/browser-menu-plugin.js");
const window_service_1 = __webpack_require__(/*! ../../browser/window/window-service */ "../../node_modules/@theia/core/lib/browser/window/window-service.js");
const window_title_service_1 = __webpack_require__(/*! ../../browser/window/window-title-service */ "../../node_modules/@theia/core/lib/browser/window/window-title-service.js");
__webpack_require__(/*! ../../../src/electron-browser/menu/electron-menu-style.css */ "../../node_modules/@theia/core/src/electron-browser/menu/electron-menu-style.css");
var ElectronCommands;
(function (ElectronCommands) {
    ElectronCommands.TOGGLE_DEVELOPER_TOOLS = common_1.Command.toDefaultLocalizedCommand({
        id: 'theia.toggleDevTools',
        label: 'Toggle Developer Tools'
    });
    ElectronCommands.RELOAD = common_1.Command.toDefaultLocalizedCommand({
        id: 'view.reload',
        label: 'Reload Window'
    });
    ElectronCommands.ZOOM_IN = common_1.Command.toDefaultLocalizedCommand({
        id: 'view.zoomIn',
        label: 'Zoom In'
    });
    ElectronCommands.ZOOM_OUT = common_1.Command.toDefaultLocalizedCommand({
        id: 'view.zoomOut',
        label: 'Zoom Out'
    });
    ElectronCommands.RESET_ZOOM = common_1.Command.toDefaultLocalizedCommand({
        id: 'view.resetZoom',
        label: 'Reset Zoom'
    });
    ElectronCommands.CLOSE_WINDOW = common_1.Command.toDefaultLocalizedCommand({
        id: 'close.window',
        label: 'Close Window'
    });
    ElectronCommands.TOGGLE_FULL_SCREEN = common_1.Command.toDefaultLocalizedCommand({
        id: 'workbench.action.toggleFullScreen',
        category: browser_1.CommonCommands.VIEW_CATEGORY,
        label: 'Toggle Full Screen'
    });
})(ElectronCommands = exports.ElectronCommands || (exports.ElectronCommands = {}));
var ElectronMenus;
(function (ElectronMenus) {
    ElectronMenus.VIEW_WINDOW = [...browser_1.CommonMenus.VIEW, 'window'];
    ElectronMenus.VIEW_ZOOM = [...browser_1.CommonMenus.VIEW_APPEARANCE_SUBMENU, '4_appearance_submenu_zoom'];
})(ElectronMenus = exports.ElectronMenus || (exports.ElectronMenus = {}));
(function (ElectronMenus) {
    ElectronMenus.HELP_TOGGLE = [...browser_1.CommonMenus.HELP, 'z_toggle'];
})(ElectronMenus = exports.ElectronMenus || (exports.ElectronMenus = {}));
(function (ElectronMenus) {
    ElectronMenus.FILE_CLOSE = [...browser_1.CommonMenus.FILE_CLOSE, 'window-close'];
})(ElectronMenus = exports.ElectronMenus || (exports.ElectronMenus = {}));
exports.CustomTitleWidgetFactory = Symbol('CustomTitleWidgetFactory');
let ElectronMenuContribution = class ElectronMenuContribution extends browser_menu_plugin_1.BrowserMenuBarContribution {
    constructor(factory) {
        super(factory);
        this.factory = factory;
        this.titleBarStyleChangeFlag = false;
    }
    onStart(app) {
        this.handleTitleBarStyling(app);
        if (common_1.isOSX) {
            this.attachWindowFocusListener(app);
        }
        // Make sure the application menu is complete, once the frontend application is ready.
        // https://github.com/theia-ide/theia/issues/5100
        let onStateChange = undefined;
        const stateServiceListener = (state) => {
            if (state === 'closing_window') {
                if (!!onStateChange) {
                    onStateChange.dispose();
                }
            }
        };
        onStateChange = this.stateService.onStateChanged(stateServiceListener);
        this.shell.mainPanel.onDidToggleMaximized(() => {
            this.handleToggleMaximized();
        });
        this.shell.bottomPanel.onDidToggleMaximized(() => {
            this.handleToggleMaximized();
        });
        this.attachMenuBarVisibilityListener();
    }
    attachWindowFocusListener(app) {
        // OSX: Recreate the menus when changing windows.
        // OSX only has one menu bar for all windows, so we need to swap
        // between them as the user switches windows.
        const disposeHandler = window.electronTheiaCore.onWindowEvent('focus', () => {
            this.setMenu(app);
        });
        window.addEventListener('unload', () => disposeHandler.dispose());
    }
    attachMenuBarVisibilityListener() {
        this.preferenceService.onPreferenceChanged(e => {
            if (e.preferenceName === 'window.menuBarVisibility') {
                this.handleFullScreen(e.newValue);
            }
        });
    }
    handleTitleBarStyling(app) {
        this.hideTopPanel(app);
        window.electronTheiaCore.getTitleBarStyleAtStartup().then(style => {
            this.titleBarStyle = style;
            this.setMenu(app);
            this.preferenceService.ready.then(() => {
                this.preferenceService.set('window.titleBarStyle', this.titleBarStyle, browser_1.PreferenceScope.User);
            });
        });
        this.preferenceService.ready.then(() => {
            window.electronTheiaCore.setMenuBarVisible(['classic', 'visible'].includes(this.preferenceService.get('window.menuBarVisibility', 'classic')));
        });
        this.preferenceService.onPreferenceChanged(change => {
            if (change.preferenceName === 'window.titleBarStyle') {
                if (this.titleBarStyleChangeFlag && this.titleBarStyle !== change.newValue) {
                    window.electronTheiaCore.setTitleBarStyle(change.newValue);
                    this.handleRequiredRestart();
                }
                this.titleBarStyleChangeFlag = true;
            }
        });
    }
    handleToggleMaximized() {
        const preference = this.preferenceService.get('window.menuBarVisibility');
        if (preference === 'classic') {
            this.factory.setMenuBar();
        }
    }
    /**
     * Hides the `theia-top-panel` depending on the selected `titleBarStyle`.
     * The `theia-top-panel` is used as the container of the main, application menu-bar for the
     * browser. Native Electron has it's own.
     * By default, this method is called on application `onStart`.
     */
    hideTopPanel(app) {
        const itr = app.shell.children();
        let child = itr.next();
        while (child) {
            // Top panel for the menu contribution is not required for native Electron title bar.
            if (child.id === 'theia-top-panel') {
                child.setHidden(this.titleBarStyle !== 'custom');
                break;
            }
            else {
                child = itr.next();
            }
        }
    }
    setMenu(app, electronMenu = this.factory.createElectronMenuBar()) {
        if (!common_1.isOSX) {
            this.hideTopPanel(app);
            if (this.titleBarStyle === 'custom' && !this.menuBar) {
                this.createCustomTitleBar(app);
                return;
            }
        }
        window.electronTheiaCore.setMenu(electronMenu);
    }
    createCustomTitleBar(app) {
        const dragPanel = new browser_1.Widget();
        dragPanel.id = 'theia-drag-panel';
        app.shell.addWidget(dragPanel, { area: 'top' });
        this.appendMenu(app.shell);
        this.createCustomTitleWidget(app);
        const controls = document.createElement('div');
        controls.id = 'window-controls';
        controls.append(this.createControlButton('minimize', () => window.electronTheiaCore.minimize()), this.createControlButton('maximize', () => window.electronTheiaCore.maximize()), this.createControlButton('restore', () => window.electronTheiaCore.unMaximize()), this.createControlButton('close', () => window.electronTheiaCore.close()));
        app.shell.topPanel.node.append(controls);
        this.handleWindowControls();
    }
    createCustomTitleWidget(app) {
        const titleWidget = this.customTitleWidgetFactory();
        if (titleWidget) {
            app.shell.addWidget(titleWidget, { area: 'top' });
        }
    }
    handleWindowControls() {
        toggleControlButtons();
        window.electronTheiaCore.onWindowEvent('maximize', toggleControlButtons);
        window.electronTheiaCore.onWindowEvent('unmaximize', toggleControlButtons);
        function toggleControlButtons() {
            if (window.electronTheiaCore.isMaximized()) {
                document.body.classList.add('maximized');
            }
            else {
                document.body.classList.remove('maximized');
            }
        }
    }
    createControlButton(id, handler) {
        const button = document.createElement('div');
        button.id = `${id}-button`;
        button.className = `control-button ${(0, browser_1.codicon)(`chrome-${id}`)}`;
        button.addEventListener('click', handler);
        return button;
    }
    async handleRequiredRestart() {
        const msgNode = document.createElement('div');
        const message = document.createElement('p');
        message.textContent = common_1.nls.localizeByDefault('A setting has changed that requires a restart to take effect.');
        const detail = document.createElement('p');
        detail.textContent = common_1.nls.localizeByDefault('Press the restart button to restart {0} and enable the setting.', frontend_application_config_provider_1.FrontendApplicationConfigProvider.get().applicationName);
        msgNode.append(message, detail);
        const restart = common_1.nls.localizeByDefault('Restart');
        const dialog = new browser_1.ConfirmDialog({
            title: restart,
            msg: msgNode,
            ok: restart,
            cancel: browser_1.Dialog.CANCEL
        });
        if (await dialog.open()) {
            this.windowService.setSafeToShutDown();
            window.electronTheiaCore.restart();
        }
    }
    registerCommands(registry) {
        registry.registerCommand(ElectronCommands.TOGGLE_DEVELOPER_TOOLS, {
            execute: () => {
                window.electronTheiaCore.toggleDevTools();
            }
        });
        registry.registerCommand(ElectronCommands.RELOAD, {
            execute: () => this.windowService.reload()
        });
        registry.registerCommand(ElectronCommands.CLOSE_WINDOW, {
            execute: () => window.electronTheiaCore.close()
        });
        registry.registerCommand(ElectronCommands.ZOOM_IN, {
            execute: async () => {
                const currentLevel = await window.electronTheiaCore.getZoomLevel();
                // When starting at a level that is not a multiple of 0.5, increment by at most 0.5 to reach the next highest multiple of 0.5.
                let zoomLevel = (Math.floor(currentLevel / electron_window_preferences_1.ZoomLevel.VARIATION) * electron_window_preferences_1.ZoomLevel.VARIATION) + electron_window_preferences_1.ZoomLevel.VARIATION;
                if (zoomLevel > electron_window_preferences_1.ZoomLevel.MAX) {
                    zoomLevel = electron_window_preferences_1.ZoomLevel.MAX;
                    return;
                }
                ;
                this.preferenceService.set('window.zoomLevel', zoomLevel, browser_1.PreferenceScope.User);
            }
        });
        registry.registerCommand(ElectronCommands.ZOOM_OUT, {
            execute: async () => {
                const currentLevel = await window.electronTheiaCore.getZoomLevel();
                // When starting at a level that is not a multiple of 0.5, decrement by at most 0.5 to reach the next lowest multiple of 0.5.
                let zoomLevel = (Math.ceil(currentLevel / electron_window_preferences_1.ZoomLevel.VARIATION) * electron_window_preferences_1.ZoomLevel.VARIATION) - electron_window_preferences_1.ZoomLevel.VARIATION;
                if (zoomLevel < electron_window_preferences_1.ZoomLevel.MIN) {
                    zoomLevel = electron_window_preferences_1.ZoomLevel.MIN;
                    return;
                }
                ;
                this.preferenceService.set('window.zoomLevel', zoomLevel, browser_1.PreferenceScope.User);
            }
        });
        registry.registerCommand(ElectronCommands.RESET_ZOOM, {
            execute: () => this.preferenceService.set('window.zoomLevel', electron_window_preferences_1.ZoomLevel.DEFAULT, browser_1.PreferenceScope.User)
        });
        registry.registerCommand(ElectronCommands.TOGGLE_FULL_SCREEN, {
            isEnabled: () => window.electronTheiaCore.isFullScreenable(),
            isVisible: () => window.electronTheiaCore.isFullScreenable(),
            execute: () => this.toggleFullScreen()
        });
    }
    registerKeybindings(registry) {
        registry.registerKeybindings({
            command: ElectronCommands.TOGGLE_DEVELOPER_TOOLS.id,
            keybinding: 'ctrlcmd+alt+i'
        }, {
            command: ElectronCommands.RELOAD.id,
            keybinding: 'ctrlcmd+r'
        }, {
            command: ElectronCommands.ZOOM_IN.id,
            keybinding: 'ctrlcmd+='
        }, {
            command: ElectronCommands.ZOOM_IN.id,
            keybinding: 'ctrlcmd+add'
        }, {
            command: ElectronCommands.ZOOM_OUT.id,
            keybinding: 'ctrlcmd+subtract'
        }, {
            command: ElectronCommands.ZOOM_OUT.id,
            keybinding: 'ctrlcmd+-'
        }, {
            command: ElectronCommands.RESET_ZOOM.id,
            keybinding: 'ctrlcmd+0'
        }, {
            command: ElectronCommands.CLOSE_WINDOW.id,
            keybinding: (common_1.isOSX ? 'cmd+shift+w' : (common_1.isWindows ? 'ctrl+w' : /* Linux */ 'ctrl+q'))
        }, {
            command: ElectronCommands.TOGGLE_FULL_SCREEN.id,
            keybinding: common_1.isOSX ? 'ctrl+ctrlcmd+f' : 'f11'
        });
    }
    registerMenus(registry) {
        registry.registerMenuAction(ElectronMenus.HELP_TOGGLE, {
            commandId: ElectronCommands.TOGGLE_DEVELOPER_TOOLS.id
        });
        registry.registerMenuAction(ElectronMenus.VIEW_WINDOW, {
            commandId: ElectronCommands.RELOAD.id,
            order: 'z0'
        });
        registry.registerMenuAction(ElectronMenus.VIEW_ZOOM, {
            commandId: ElectronCommands.ZOOM_IN.id,
            order: 'z1'
        });
        registry.registerMenuAction(ElectronMenus.VIEW_ZOOM, {
            commandId: ElectronCommands.ZOOM_OUT.id,
            order: 'z2'
        });
        registry.registerMenuAction(ElectronMenus.VIEW_ZOOM, {
            commandId: ElectronCommands.RESET_ZOOM.id,
            order: 'z3'
        });
        registry.registerMenuAction(ElectronMenus.FILE_CLOSE, {
            commandId: ElectronCommands.CLOSE_WINDOW.id,
        });
        registry.registerMenuAction(browser_1.CommonMenus.VIEW_APPEARANCE_SUBMENU_SCREEN, {
            commandId: ElectronCommands.TOGGLE_FULL_SCREEN.id,
            label: common_1.nls.localizeByDefault('Full Screen'),
            order: '0'
        });
    }
    toggleFullScreen() {
        window.electronTheiaCore.toggleFullScreen();
        const menuBarVisibility = this.preferenceService.get('window.menuBarVisibility', 'classic');
        this.handleFullScreen(menuBarVisibility);
    }
    handleFullScreen(menuBarVisibility) {
        const shouldShowTop = !window.electronTheiaCore.isFullScreen() || menuBarVisibility === 'visible';
        if (this.titleBarStyle === 'native') {
            window.electronTheiaCore.setMenuBarVisible(shouldShowTop);
        }
        else if (shouldShowTop) {
            this.shell.topPanel.show();
        }
        else {
            this.shell.topPanel.hide();
        }
    }
};
__decorate([
    (0, inversify_1.inject)(frontend_application_state_1.FrontendApplicationStateService),
    __metadata("design:type", frontend_application_state_1.FrontendApplicationStateService)
], ElectronMenuContribution.prototype, "stateService", void 0);
__decorate([
    (0, inversify_1.inject)(window_service_1.WindowService),
    __metadata("design:type", Object)
], ElectronMenuContribution.prototype, "windowService", void 0);
__decorate([
    (0, inversify_1.inject)(exports.CustomTitleWidgetFactory),
    __metadata("design:type", Function)
], ElectronMenuContribution.prototype, "customTitleWidgetFactory", void 0);
ElectronMenuContribution = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(electron_main_menu_factory_1.ElectronMainMenuFactory)),
    __metadata("design:paramtypes", [electron_main_menu_factory_1.ElectronMainMenuFactory])
], ElectronMenuContribution);
exports.ElectronMenuContribution = ElectronMenuContribution;
let CustomTitleWidget = class CustomTitleWidget extends browser_1.Widget {
    constructor() {
        super();
        this.id = 'theia-custom-title';
    }
    init() {
        this.updateTitle(this.windowTitleService.title);
        this.windowTitleService.onDidChangeTitle(title => {
            this.updateTitle(title);
        });
    }
    onResize(msg) {
        this.adjustTitleToCenter();
        super.onResize(msg);
    }
    onAfterShow(msg) {
        this.adjustTitleToCenter();
        super.onAfterShow(msg);
    }
    updateTitle(title) {
        this.node.textContent = title;
        this.adjustTitleToCenter();
    }
    adjustTitleToCenter() {
        const menubar = this.electronMenuContribution.menuBar;
        if (menubar) {
            const titleWidth = this.node.clientWidth;
            const margin = 16;
            const leftMarker = menubar.node.offsetLeft + menubar.node.clientWidth + margin;
            const panelWidth = this.applicationShell.topPanel.node.clientWidth;
            const controlsWidth = 48 * 3; // Each window button has a width of 48px
            const rightMarker = panelWidth - controlsWidth - margin;
            let hidden = false;
            let relative = false;
            this.node.style.left = '50%';
            // The title has not enough space between the menu and the window controls
            // So we simply hide it
            if (rightMarker - leftMarker < titleWidth) {
                hidden = true;
            }
            else if ((panelWidth - titleWidth) / 2 < leftMarker || (panelWidth + titleWidth) / 2 > rightMarker) {
                // This indicates that the title has either hit the left (menu) or right (window controls) marker
                relative = true;
                this.node.style.left = `${leftMarker + (rightMarker - leftMarker - titleWidth) / 2}px`;
            }
            this.node.classList.toggle('hidden', hidden);
            this.node.classList.toggle('relative', relative);
        }
    }
};
__decorate([
    (0, inversify_1.inject)(ElectronMenuContribution),
    __metadata("design:type", ElectronMenuContribution)
], CustomTitleWidget.prototype, "electronMenuContribution", void 0);
__decorate([
    (0, inversify_1.inject)(window_title_service_1.WindowTitleService),
    __metadata("design:type", window_title_service_1.WindowTitleService)
], CustomTitleWidget.prototype, "windowTitleService", void 0);
__decorate([
    (0, inversify_1.inject)(browser_1.ApplicationShell),
    __metadata("design:type", browser_1.ApplicationShell)
], CustomTitleWidget.prototype, "applicationShell", void 0);
__decorate([
    (0, inversify_1.postConstruct)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], CustomTitleWidget.prototype, "init", null);
CustomTitleWidget = __decorate([
    (0, inversify_1.injectable)(),
    __metadata("design:paramtypes", [])
], CustomTitleWidget);
exports.CustomTitleWidget = CustomTitleWidget;


/***/ }),

/***/ "../../node_modules/@theia/core/lib/electron-browser/menu/electron-menu-module.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@theia/core/lib/electron-browser/menu/electron-menu-module.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2017 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/lib/inversify.js");
const common_1 = __webpack_require__(/*! ../../common */ "../../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! ../../browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const electron_main_menu_factory_1 = __webpack_require__(/*! ./electron-main-menu-factory */ "../../node_modules/@theia/core/lib/electron-browser/menu/electron-main-menu-factory.js");
const electron_context_menu_renderer_1 = __webpack_require__(/*! ./electron-context-menu-renderer */ "../../node_modules/@theia/core/lib/electron-browser/menu/electron-context-menu-renderer.js");
const electron_menu_contribution_1 = __webpack_require__(/*! ./electron-menu-contribution */ "../../node_modules/@theia/core/lib/electron-browser/menu/electron-menu-contribution.js");
exports["default"] = new inversify_1.ContainerModule(bind => {
    bind(electron_main_menu_factory_1.ElectronMainMenuFactory).toSelf().inSingletonScope();
    bind(browser_1.ContextMenuRenderer).to(electron_context_menu_renderer_1.ElectronContextMenuRenderer).inSingletonScope();
    bind(browser_1.KeybindingContext).toConstantValue({
        id: 'theia.context',
        isEnabled: true
    });
    bind(electron_menu_contribution_1.ElectronMenuContribution).toSelf().inSingletonScope();
    for (const serviceIdentifier of [browser_1.FrontendApplicationContribution, browser_1.KeybindingContribution, common_1.CommandContribution, common_1.MenuContribution]) {
        bind(serviceIdentifier).toService(electron_menu_contribution_1.ElectronMenuContribution);
    }
    bind(electron_menu_contribution_1.CustomTitleWidget).toSelf().inSingletonScope();
    bind(electron_menu_contribution_1.CustomTitleWidgetFactory).toFactory(context => () => context.container.get(electron_menu_contribution_1.CustomTitleWidget));
    bind(browser_1.FrontendApplicationContribution).to(electron_context_menu_renderer_1.ElectronTextInputContextMenuContribution).inSingletonScope();
    bind(common_1.MenuContribution).to(electron_context_menu_renderer_1.ElectronTextInputContextMenuContribution).inSingletonScope();
});


/***/ }),

/***/ "../../node_modules/@theia/core/lib/electron-browser/window/electron-window-preferences.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/@theia/core/lib/electron-browser/window/electron-window-preferences.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2021 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bindWindowPreferences = exports.createElectronWindowPreferences = exports.ElectronWindowPreferences = exports.ElectronWindowPreferenceContribution = exports.ElectronWindowConfiguration = exports.electronWindowPreferencesSchema = exports.ZoomLevel = void 0;
const nls_1 = __webpack_require__(/*! ../../common/nls */ "../../node_modules/@theia/core/lib/common/nls.js");
const preferences_1 = __webpack_require__(/*! ../../browser/preferences */ "../../node_modules/@theia/core/lib/browser/preferences/index.js");
const common_1 = __webpack_require__(/*! ../../common */ "../../node_modules/@theia/core/lib/common/index.js");
var ZoomLevel;
(function (ZoomLevel) {
    ZoomLevel.DEFAULT = 0;
    // copied from https://github.com/microsoft/vscode/blob/dda96b69bfc63f309e60cfc5f98cb863c46b32ac/src/vs/workbench/electron-sandbox/actions/windowActions.ts#L47-L48
    ZoomLevel.MIN = -8;
    ZoomLevel.MAX = 9;
    // amount to increment or decrement the window zoom level.
    ZoomLevel.VARIATION = 0.5;
})(ZoomLevel = exports.ZoomLevel || (exports.ZoomLevel = {}));
exports.electronWindowPreferencesSchema = {
    type: 'object',
    properties: {
        'window.zoomLevel': {
            'type': 'number',
            'default': ZoomLevel.DEFAULT,
            'minimum': ZoomLevel.MIN,
            'maximum': ZoomLevel.MAX,
            'scope': 'application',
            // eslint-disable-next-line max-len
            'description': nls_1.nls.localizeByDefault('Adjust the zoom level of the window. The original size is 0 and each increment above (e.g. 1) or below (e.g. -1) represents zooming 20% larger or smaller. You can also enter decimals to adjust the zoom level with a finer granularity.')
        },
        'window.titleBarStyle': {
            type: 'string',
            enum: ['native', 'custom'],
            default: common_1.isWindows ? 'custom' : 'native',
            scope: 'application',
            // eslint-disable-next-line max-len
            description: nls_1.nls.localizeByDefault('Adjust the appearance of the window title bar. On Linux and Windows, this setting also affects the application and context menu appearances. Changes require a full restart to apply.'),
            included: !common_1.isOSX
        },
    }
};
class ElectronWindowConfiguration {
}
exports.ElectronWindowConfiguration = ElectronWindowConfiguration;
exports.ElectronWindowPreferenceContribution = Symbol('ElectronWindowPreferenceContribution');
exports.ElectronWindowPreferences = Symbol('ElectronWindowPreferences');
function createElectronWindowPreferences(preferences, schema = exports.electronWindowPreferencesSchema) {
    return (0, preferences_1.createPreferenceProxy)(preferences, schema);
}
exports.createElectronWindowPreferences = createElectronWindowPreferences;
function bindWindowPreferences(bind) {
    bind(exports.ElectronWindowPreferences).toDynamicValue(ctx => {
        const preferences = ctx.container.get(preferences_1.PreferenceService);
        const contribution = ctx.container.get(exports.ElectronWindowPreferenceContribution);
        return createElectronWindowPreferences(preferences, contribution.schema);
    }).inSingletonScope();
    bind(exports.ElectronWindowPreferenceContribution).toConstantValue({ schema: exports.electronWindowPreferencesSchema });
    bind(preferences_1.PreferenceContribution).toService(exports.ElectronWindowPreferenceContribution);
}
exports.bindWindowPreferences = bindWindowPreferences;


/***/ }),

/***/ "../../node_modules/@theia/core/src/electron-browser/menu/electron-menu-style.css":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@theia/core/src/electron-browser/menu/electron-menu-style.css ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_cjs_js_electron_menu_style_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../../../css-loader/dist/cjs.js!./electron-menu-style.css */ "../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/core/src/electron-browser/menu/electron-menu-style.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_electron_menu_style_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_electron_menu_style_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_theia_core_lib_electron-browser_menu_electron-menu-module_js.js.map