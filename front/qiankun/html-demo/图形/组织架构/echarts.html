<!doctype html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>组织架构 - 思维导图 (ECharts)</title>
  <style>
    html,
    body,
    #chart {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    #chart {
      width: 500px;
      height: 500px;
    }
  </style>
</head>

<body>
  <div id="chart"></div>

  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <script>
    const chart = echarts.init(document.getElementById('chart'));

    const data = {
      name: '公司',
      children: [
        {
          name: '产品',
          children: [
            { name: '产品规划' },
            { name: '需求分析' },
            { name: '产品运营' }
          ]
        },
        {
          name: '研发',
          children: [
            {
              name: '前端',
              children: [
                { name: 'Vue' },
                { name: 'React' }
              ]
            },
            {
              name: '后端',
              children: [
                { name: 'Java' },
                { name: 'Node.js' }
              ]
            },
            { name: '测试' }
          ]
        },
        {
          name: '设计',
          children: [
            { name: '视觉\n111111111111111\n111111111\n11111111111' },
            { name: '交互' }
          ]
        },
        {
          name: '运营',
          children: [
            { name: '市场' },
            { name: '内容' }
          ]
        },{
          name: '运营',
          children: [
            { name: '市场' },
            { name: '内容' }
          ]
        },{
          name: '运营',
          children: [
            { name: '市场' },
            { name: '内容' }
          ]
        },{
          name: '运营',
          children: [
            { name: '市场' },
            { name: '内容' }
          ]
        }
      ]
    };

    // 为每个节点分配合适的 symbolSize（根据文字长度自适应宽度）
    function assignSymbolSize(node) {
      if (!node) return;
      const raw = (node.name || '').toString();
      const approxCharWidth = 8; // 每个字符近似像素宽度
      const hPadding = 28; // 水平内边距（左右总和）
      const vPadding = 12; // 垂直内边距（上下总和）
      const minW = 80; const maxW = 180;

      // 先按最大宽度计算每行最多字符数，用于切分长行
      const maxCharsAtMaxW = Math.max(1, Math.floor((maxW - hPadding) / approxCharWidth));

      // 处理已有换行或按 maxCharsAtMaxW 切分长文本
      const rawLines = raw.indexOf('\n') >= 0 ? raw.split('\n') : [raw];
      const lines = [];
      for (const ln of rawLines) {
        if (ln.length === 0) { lines.push(''); continue; }
        for (let i = 0; i < ln.length; i += maxCharsAtMaxW) {
          lines.push(ln.slice(i, i + maxCharsAtMaxW));
        }
      }

      // 计算最终宽度基于最长行
      const maxLineLen = lines.reduce((m, s) => Math.max(m, s.length), 0);
      const w = Math.max(minW, Math.min(maxW, Math.round(maxLineLen * approxCharWidth + hPadding)));

      // 计算高度：每行行高 + 垂直内边距
      const lineHeight = 18;
      const h = Math.max(40, lines.length * lineHeight + vPadding);

      node.symbolSize = [w, h];
      node._wrappedName = lines.join('\n');
      if (node.children && node.children.length) node.children.forEach(assignSymbolSize);
    }
    assignSymbolSize(data);

    // 计算最大节点宽度（保留）
    function computeMaxWidth(node) {
      if (!node) return 0;
      let maxW = 0;
      if (node.symbolSize && node.symbolSize[0]) maxW = node.symbolSize[0];
      if (node.children && node.children.length) {
        for (const c of node.children) maxW = Math.max(maxW, computeMaxWidth(c));
      }
      return maxW;
    }
    const maxNodeWidth = computeMaxWidth(data);

    // 更精确地计算兄弟间距：对每个父节点，计算相邻子节点所需的最小间距（(w_i + w_j)/2 + margin），
    // 取全局最大值作为 nodeGap，保证任意相邻子节点的边缘不会重叠。
    function computeRequiredNodeGap(root) {
      let required = 40;
      function walk(n) {
        if (!n || !n.children || n.children.length === 0) return;
        const widths = n.children.map(c => (c.symbolSize && c.symbolSize[0]) ? c.symbolSize[0] : 140);
        for (let i = 0; i < widths.length - 1; i++) {
          const gap = Math.ceil((widths[i] + widths[i + 1]) / 2) + 24; // 24 px margin
          if (gap > required) required = gap;
        }
        for (const c of n.children) walk(c);
      }
      walk(root);
      return required;
    }

    const computedNodeGap = Math.max(40, computeRequiredNodeGap(data));

    const option = {
      tooltip: {
        trigger: 'item',
        triggerOn: 'mousemove'
      },
      series: [
        {
          type: 'tree',
          data: [data],
          top: '5%',
          left: '5%',
          bottom: '2%',
          right: '20%',
          // 使用矩形容器包裹文字
          symbol: 'rect',
          symbolKeepAspect: false,
          symbolSize: function (node) { if (node && node.data && node.data.symbolSize) return node.data.symbolSize; return [140, 40]; },
          orient: 'TB', // 竖向布局（Top -> Bottom）
          // 增加兄弟节点水平间距，基于最大节点宽度自动计算以避免重叠
          nodeGap: computedNodeGap,
          // 层间距离（增加以避免纵向重叠）
          layerGap: 120,
          expandAndCollapse: true,
          initialTreeDepth: 2,
          roam: true,
          edgeShape: 'polyline', // 使用折线/直线连接节点
          // 调整布局边距以适配竖向展示
          top: '5%',
          left: '8%',
          right: '8%',
          bottom: '5%',
          label: {
            position: 'inside',
            verticalAlign: 'middle',
            align: 'center',
            fontSize: 14,
            color: '#2b2f8f',
            // 使用 formatter 返回带换行的文本
            formatter: function (node) { return node && node.data && node.data._wrappedName ? node.data._wrappedName : (node && node.data ? node.data.name : ''); },
            // 内部不额外 padding，矩形大小由 symbolSize 控制
            padding: 0
          },
          leaves: {
            label: {
              position: 'inside',
              verticalAlign: 'middle',
              align: 'center',
              formatter: function (node) { return node && node.data && node.data._wrappedName ? node.data._wrappedName : (node && node.data ? node.data.name : ''); }
            }
          },
          itemStyle: {
            borderColor: '#2f6ae6',
            borderWidth: 1,
            color: '#eef2ff'
          },
          lineStyle: {
            color: '#ccc',
            width: 1.5,
            curveness: 0 // 直线（0 表示无曲率）
          }
        }
      ]
    };

    chart.setOption(option);

    // 点击节点显示简单信息
    chart.on('click', params => {
      if (params && params.data) {
        const name = params.data.name || '';
        alert('节点：' + name);
      }
    });

    // 自适应窗口
    window.addEventListener('resize', () => chart.resize());
  </script>
</body>

</html>